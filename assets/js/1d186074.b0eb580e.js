(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{113:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var r=n(0),o=n.n(r);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=o.a.createContext({}),u=function(e){var t=o.a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=u(e.components);return o.a.createElement(d.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},b=o.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=u(n),b=r,m=p["".concat(i,".").concat(b)]||p[b]||l[b]||a;return n?o.a.createElement(m,c(c({ref:t},d),{},{components:n})):o.a.createElement(m,c({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=b;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var d=2;d<a;d++)i[d]=n[d];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},83:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return u}));var r=n(3),o=n(7),a=(n(0),n(113)),i={sidebar_position:3},c={unversionedId:"design-documents/ota",id:"design-documents/ota",isDocsHomePage:!1,title:"Over the Air (OTA) Package Files",description:"Objective",source:"@site/docs/design-documents/ota.md",sourceDirName:"design-documents",slug:"/design-documents/ota",permalink:"/docs/design-documents/ota",editUrl:"https://github.com/hydro-sdk/hydro-sdk.io/edit/main/docs/design-documents/ota.md",version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Common Flutter Runtime (CFR)",permalink:"/docs/design-documents/cfr"},next:{title:"Registry",permalink:"/docs/design-documents/registry"}},s=[{value:"Objective",id:"objective",children:[]},{value:"Background",id:"background",children:[]},{value:"<code>.ota</code> Package Format",id:"ota-package-format",children:[]},{value:"Future Work",id:"future-work",children:[]}],d={toc:s};function u(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"objective"},"Objective"),Object(a.b)("p",null,"Provide a packaging and distribution format for code built using Hydro-SDK."),Object(a.b)("h2",{id:"background"},"Background"),Object(a.b)("p",null,Object(a.b)("a",{parentName:"p",href:"https://hydro-sdk.io/docs/design-documents/cfr"},"Common Flutter Runtime (CFR)")," provides an execution environment for Lua 5.2 bytecode chunks. The Lua 5.2 bytecode chunk format is not suitable for more general usecases."),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},".ota")," package files are used during development time. They are produced and served by the ",Object(a.b)("inlineCode",{parentName:"p"},"run-project")," SDK-tool and consumed by the ",Object(a.b)("inlineCode",{parentName:"p"},"RunComponent")," widget in a running host app. In release mode, the ",Object(a.b)("inlineCode",{parentName:"p"},"RunComponent")," widget downloads ",Object(a.b)("inlineCode",{parentName:"p"},".ota")," package files from Registry and saves them in an on-device cache. "),Object(a.b)("h2",{id:"ota-package-format"},Object(a.b)("inlineCode",{parentName:"h2"},".ota")," Package Format"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},".ota")," files are tar archives compressed with bzip2. A ",Object(a.b)("inlineCode",{parentName:"p"},"manifest.json")," file in their root contains an ",Object(a.b)("inlineCode",{parentName:"p"},"entries")," array listing the path and sha256 hash of every contained file. The ",Object(a.b)("inlineCode",{parentName:"p"},"mountableChunk")," field in ",Object(a.b)("inlineCode",{parentName:"p"},"manifest.json")," contains the path to the bytecode chunk to be ran by CFR. The ",Object(a.b)("inlineCode",{parentName:"p"},"signature")," field in ",Object(a.b)("inlineCode",{parentName:"p"},"manifest.json")," contains the signature of the sha256 hash of the concatentation of all of the sha256 hashes of every file contained in the package, signed using an RSA private key. This signature can be verified using the associated package public key."),Object(a.b)("h2",{id:"future-work"},"Future Work"),Object(a.b)("p",null,"It is expected in the future that ",Object(a.b)("inlineCode",{parentName:"p"},".ota")," packages will be used to deliver assets like images and configuration files."))}u.isMDXComponent=!0}}]);